"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTsconfigFiles = updateTsconfigFiles;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const configuration_1 = require("@nx/js/src/utils/typescript/configuration");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const semver_1 = require("semver");
const update_app_editor_tsconfig_excluded_files_1 = require("../../utils/update-app-editor-tsconfig-excluded-files");
const version_utils_1 = require("../../utils/version-utils");
const enable_strict_type_checking_1 = require("./enable-strict-type-checking");
function updateTsconfigFiles(tree, options) {
    (0, enable_strict_type_checking_1.enableStrictTypeChecking)(tree, options);
    updateEditorTsConfig(tree, options);
    const compilerOptions = {
        skipLibCheck: true,
        experimentalDecorators: true,
        importHelpers: true,
        target: 'es2022',
        moduleResolution: 'bundler',
    };
    const rootTsConfigPath = (0, js_1.getRootTsConfigFileName)(tree);
    const { major: angularMajorVersion, version: angularVersion } = (0, version_utils_1.getInstalledAngularVersionInfo)(tree);
    if ((0, semver_1.lt)(angularVersion, '18.1.0')) {
        compilerOptions.useDefineForClassFields = false;
    }
    if ((0, semver_1.gte)(angularVersion, '18.2.0')) {
        compilerOptions.isolatedModules = true;
    }
    if ((0, semver_1.gte)(angularVersion, '19.1.0')) {
        // Angular started warning about emitDecoratorMetadata and isolatedModules
        // in v19.1.0. If enabled in the root tsconfig, we need to disable it.
        if (shouldDisableEmitDecoratorMetadata(tree, rootTsConfigPath)) {
            compilerOptions.emitDecoratorMetadata = false;
        }
    }
    if (angularMajorVersion >= 20) {
        compilerOptions.module = 'preserve';
    }
    else {
        compilerOptions.module = 'es2022';
        if (options.bundler === 'esbuild') {
            compilerOptions.esModuleInterop = true;
        }
    }
    const tsconfigPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.json');
    (0, devkit_1.updateJson)(tree, tsconfigPath, (json) => {
        json.compilerOptions = {
            ...json.compilerOptions,
            ...compilerOptions,
        };
        json.compilerOptions = (0, configuration_1.getNeededCompilerOptionOverrides)(tree, json.compilerOptions, rootTsConfigPath);
        return json;
    });
    if (options.unitTestRunner === 'jest') {
        const tsconfigSpecPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.spec.json');
        (0, devkit_1.updateJson)(tree, tsconfigSpecPath, (json) => {
            json.compilerOptions = {
                ...json.compilerOptions,
                module: 'commonjs',
                moduleResolution: 'node10',
            };
            json.compilerOptions = (0, configuration_1.getNeededCompilerOptionOverrides)(tree, json.compilerOptions, tsconfigPath);
            return json;
        });
    }
}
function updateEditorTsConfig(tree, options) {
    const tsconfigEditorPath = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.editor.json');
    if (!tree.exists(tsconfigEditorPath)) {
        return;
    }
    const appTsConfig = (0, devkit_1.readJson)(tree, (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'));
    const types = appTsConfig?.compilerOptions?.types ?? [];
    if (types?.length) {
        (0, devkit_1.updateJson)(tree, (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.editor.json'), (json) => {
            json.compilerOptions ??= {};
            json.compilerOptions.types = Array.from(new Set(types));
            return json;
        });
    }
    const project = (0, devkit_1.readProjectConfiguration)(tree, options.name);
    (0, update_app_editor_tsconfig_excluded_files_1.updateAppEditorTsConfigExcludedFiles)(tree, project);
}
function shouldDisableEmitDecoratorMetadata(tree, tsConfigPath) {
    const ts = (0, ensure_typescript_1.ensureTypescript)();
    const tsSysFromTree = {
        ...ts.sys,
        readFile: (path) => tree.read(path, 'utf-8'),
    };
    const parsed = ts.parseJsonConfigFileContent(ts.readConfigFile(tsConfigPath, tsSysFromTree.readFile).config, tsSysFromTree, tree.root);
    return parsed.options.emitDecoratorMetadata === true;
}
